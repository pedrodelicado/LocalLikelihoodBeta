---
title: "One simulated Beta curve"
author: "Pedro Delicado and Nihan Acar-Denizli"
date: "2025-10-18"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
do_pdf <- FALSE
set.seed(12321)
```

## Defining the curves $\alpha(t)$ and $\beta(t)$

```{r}
m <- 201 # 1001 # 201
t <- seq(0,1,length=m)

Cte <- .75
#Cte <- 1
a0 <- 2.5
a1 <- -5
a2 <- 5
#alpha <- Cte*exp((a0+a1*t))
alpha <- exp(Cte*(a0+a1*t+a2*(t-.5)^2))

b0 <- 1.5
b1 <- 5
b2 <- -5
#beta <- Cte*exp((b0+b1*t))
beta <- exp(Cte*(b0+b1*t+b2*t^2))

plot(t,log(alpha), type="l", 
     lwd=2, lty=1,
     ylim=range(c(log(alpha),log(beta))),
     ylab=c("log(alpha), log(beta)"),
     main=c("log(alpha(t)) ___    log(beta(t)) _ _"))
lines(t, log(beta), lwd=2, lty=2)
```


```{r}
plot(t,alpha, type="l", lwd=2, lty=1,
     ylim=range(c(alpha, beta)),
     ylab=expression(paste(alpha(t),",  ",beta(t))),
     main=expression(paste(alpha(t)," ___    ",    beta(t)," _  _")))
lines(t, beta, lwd=2, lty=2)
```


```{r}
mu <- alpha/(alpha+beta)
sigma2 <- alpha*beta/((alpha+beta+1)*(alpha+beta)^2)

q025 <- qbeta(.025,alpha,beta)
q500 <- qbeta(.5,alpha,beta)
q975 <- qbeta(.975,alpha,beta)

plot(t,mu, ylim=c(0,1))
plot(t,sqrt(sigma2))
```

## Random data generation 

```{r}
Y <- rbeta(m,shape1 = alpha, shape2 = beta)

plot(t,t(Y), ylim=c(0,1), pch=19)
lines(t,mu,lwd=2)
lines(t,mu+qnorm(.9)*sqrt(sigma2),lwd=2,col=2,lty=2)
lines(t,mu+qnorm(.1)*sqrt(sigma2),lwd=2,col=2,lty=2)
```


```{r}
plot(t,Y, ylim=c(0,1), 
     xlab=expression(t[j]),
     ylab=expression(Y(t[j])),
     pch=19, cex=.5, col="darkgreen")
lines(t,mu,lwd=2)
lines(t,q500,lwd=3,col=2,lty=2)
lines(t,q025,lwd=3,col=4,lty=4)
lines(t,q975,lwd=3,col=4,lty=4)

legend("topright",
       c("Mean", "Median", "Q_0.025, Q_0.975"),
       col=c(1,2,4), lty=c(1,2,4), lwd=c(2,3,3),
       bty="n", cex=.5, seg.len = 3.5)
```


## Estimation

### Reading functions for local maximum likelihood Beta estimation

```{r}
source("generic_functions.R")
source("local_linear_functions.R")
source("local_constant_functions.R")
```



### Estimation: Local constant likelihood

```{r}
# Sample of size m=201
# t <- t
y <- Y
newt <- seq(0,1,length=101) 
mv <- FALSE
myBeta <- FALSE
h <- .06 # .075  # (.06 is h_star, found later)

# local constant: 2 parameters


loclikBeta_out_lc_1 <- loc_lik_Beta_2(t=t,y=y, h=h, newt=newt, myBeta=myBeta, mv=mv, method="Nelder-Mead")
loclikBeta_out_lc_2 <- loc_lik_Beta_2(t=t,y=y, h=h, newt=newt, myBeta=myBeta, mv=mv, method="BFGS", gr=grad_local_log_lik_2)
loclikBeta_out_lc_3 <- loc_lik_Beta_nlm_2(t=t, y=y, h=h, newt=newt, myBeta=myBeta, mv=mv) 

loclikBeta_out <- loclikBeta_out_lc_3

if (mv){
  npar <- dim(loclikBeta_out$ab)[2] # 2 or 4
  par1 <- loclikBeta_out$ab[,1] 
#  par1 <- smooth.spline(newt,par1,df=15)$y
  par2 <- loclikBeta_out$ab[,1+npar/2]
#  par2 <- smooth.spline(newt,par2,df=15)$y
  mu  <- exp(par1)/(1+exp(par1))
  var <- exp(par2)
  aux_denom <- mu*(1-mu)/var - 1
  alphat <- mu*aux_denom   # alpha
  betat <- aux_denom - alphat # beta
  mt <- mu
  st <- sqrt(var)
}else{
  deltat <- loclikBeta_out$deltat 
#  deltat <-  smooth.spline(newt,deltat,df=15)$y
  etat <- loclikBeta_out$etat
#  etat <-  smooth.spline(newt,etat,df=15)$y
  alphat <- exp(deltat) 
  betat <- exp(etat)
  mt <- alphat/(alphat+betat)
  st <- sqrt(mt*(1-mt)/(alphat+betat+1))
}

q025t <- qbeta(.025,alphat,betat)
q500t <- qbeta(.5,alphat,betat)
q975t <- qbeta(.975,alphat,betat)
```


```{r}
plot(t,y, ylim=c(0,1), pch=19, cex=.5,col="darkgreen")
lines(newt,mt,col=1,lwd=2)
lines(newt,q500t,col=2,lty=2,lwd=3)
lines(newt,q025t,col=4,lty=4,lwd=3)
lines(newt,q975t,col=4,lty=4,lwd=3)
```


### Estimation: Local linear likelihood

```{r}
# Sample of size m=201
# t <- t
y <- Y
newt <- seq(0,1,length=101) 
mv <- FALSE
myBeta <- FALSE
h <- .12 # .1  (.12 is h_star, found later) 

# local linear: 4 parameters

loclikBeta_out_ll_1 <- loc_lik_Beta(t=t,y=y, h=h, newt=newt, myBeta=myBeta, mv=mv)
loclikBeta_out_ll_2 <- loc_lik_Beta(t=t,y=y, h=h, newt=newt, myBeta=myBeta, mv=mv, method="BFGS", gr=grad_local_log_lik)
loclikBeta_out_ll_3  <- loc_lik_Beta_nlm(t=t, y=y, h=h, newt=newt, myBeta=myBeta, mv=mv)

loclikBeta_out  <- loclikBeta_out_ll_2

if (mv){
  npar <- dim(loclikBeta_out$ab)[2] # 2 or 4
  par1 <- loclikBeta_out$ab[,1] 
#  par1 <- smooth.spline(newt,par1,df=15)$y
  par2 <- loclikBeta_out$ab[,1+npar/2]
#  par2 <- smooth.spline(newt,par2,df=15)$y
  mu  <- exp(par1)/(1+exp(par1))
  var <- exp(par2)
  aux_denom <- mu*(1-mu)/var - 1
  alphat <- mu*aux_denom   # alpha
  betat <- aux_denom - alphat # beta
  mt <- mu
  st <- sqrt(var)
}else{
  deltat <- loclikBeta_out$deltat 
#  deltat <-  smooth.spline(newt,deltat,df=15)$y
  etat <- loclikBeta_out$etat
#  etat <-  smooth.spline(newt,etat,df=15)$y
  alphat <- exp(deltat) 
  betat <- exp(etat)
  mt <- alphat/(alphat+betat)
  st <- sqrt(mt*(1-mt)/(alphat+betat+1))
}

q025t <- qbeta(.025,alphat,betat)
q500t <- qbeta(.5,alphat,betat)
q975t <- qbeta(.975,alphat,betat)
```


```{r}
plot(t,y, ylim=c(0,1), pch=19, cex=.5,col="darkgreen")
lines(newt,mt,col=1,lwd=2)
lines(newt,q500t,col=2,lty=2,lwd=3)
lines(newt,q025t,col=4,lty=4,lwd=3)
lines(newt,q975t,col=4,lty=4,lwd=3)
```

### Comparing 6 different estimators

#### Estimation performance

```{r,fig.width=7.2,fig.height=3.6}
if (do_pdf) pdf(file="One_Sim_Beta_m_201_6_estims.pdf",
                width=7.2,height=3.6)
op <-par(mfrow=c(1,2))
plot(t,alpha,type="l",lwd=2, ylab=expression(alpha(t)))
lines(newt, exp(loclikBeta_out_lc_1$deltat),lwd=2, col=5, lty=2)
lines(newt, exp(loclikBeta_out_lc_2$deltat),lwd=2, col=3, lty=2)
lines(newt, exp(loclikBeta_out_lc_3$deltat),lwd=2, col=2, lty=2)
lines(newt, exp(loclikBeta_out_ll_1$deltat),lwd=2, col=7, lty=4)
lines(newt, exp(loclikBeta_out_ll_2$deltat),lwd=2, col=6, lty=4)
lines(newt, exp(loclikBeta_out_ll_3$deltat),lwd=2, col=4, lty=4)
legend("topright",
       c(expression(paste("True ", alpha,"(t)")),
         "3 local constant estims", 
         "3 local linear estims"),
       col=c(1,2,4),lwd=2,
       lty=c(1,2,4),
       bty="n", cex=.75, seg.len = 3.5)

plot(t,beta,type="l",lwd=2, ylab=expression(beta(t)), ylim=range(alpha))
lines(newt, exp(loclikBeta_out_lc_1$eta),lwd=2, col=5, lty=2)
lines(newt, exp(loclikBeta_out_lc_2$eta),lwd=2, col=3, lty=2)
lines(newt, exp(loclikBeta_out_lc_3$eta),lwd=2, col=2, lty=2)
lines(newt, exp(loclikBeta_out_ll_1$eta),lwd=2, col=7, lty=4)
lines(newt, exp(loclikBeta_out_ll_2$eta),lwd=2, col=6, lty=4)
lines(newt, exp(loclikBeta_out_ll_3$eta),lwd=2, col=4, lty=4)
legend("topright",
       c(expression(paste("True ", beta,"(t)")),
         "3 local constant estims", 
         "3 local linear estims"),
       col=c(1,2,4),lwd=2,
       lty=c(1,2,4),
       bty="n", cex=.75, seg.len = 3.5)
par(op)

if (do_pdf) dev.off()
```

#### Computing time

```{r, eval=FALSE, echo=FALSE}
library(microbenchmark)
mb_times <- microbenchmark(
  lc_Nelder_Mead=loc_lik_Beta_2(t=t,y=y, h=h, newt=newt, myBeta=myBeta, mv=mv),
  lc_BFGS=loc_lik_Beta_2(t=t,y=y, h=h, newt=newt, myBeta=myBeta, mv=mv, method="BFGS", gr=grad_local_log_lik_2),
  lc_NLM=loc_lik_Beta_nlm_2(t=t, y=y, h=h, newt=newt, myBeta=myBeta, mv=mv),
  ll_Nelder_Mead=loc_lik_Beta(t=t,y=y, h=h, newt=newt, myBeta=myBeta, mv=mv),
  ll_BFGS=loc_lik_Beta(t=t,y=y, h=h, newt=newt, myBeta=myBeta, mv=mv, method="BFGS", gr=grad_local_log_lik),
  ll_NLM=loc_lik_Beta_nlm(t=t, y=y, h=h, newt=newt, myBeta=myBeta, mv=mv),
  times=10
)
```


```{r, fig.width=7,fig.height=5, eval=FALSE, echo=FALSE}
if (do_pdf) pdf(file="box_plot_micro_bench_m_201.pdf", width=7, height=5)
#if (do_pdf) pdf(file="box_plot_micro_bench_m_1001.pdf", width=7, height=5)
summary(mb_times)
# m=201:
#Unit: milliseconds
#             expr       min        lq       mean     median        uq       max neval
# 1 lc_Nelder_Mead  218.5858  239.9247  250.22380  243.63100  250.3775  298.1790    10
# 2        lc_BFGS   79.7568   82.7506  106.47682   88.07505  104.9944  200.5937    10
# 3         lc_NLM   44.3620   45.8548   55.94153   50.59635   55.1942   94.8627    10
# 4 ll_Nelder_Mead 1854.0138 1939.2801 2140.04123 2162.27490 2204.3362 2606.0346    10
# 5        ll_BFGS  433.7535  469.0023  517.67281  504.63940  527.2358  655.7318    10
# 6         ll_NLM  446.1252  454.3509  512.62236  492.01160  538.4956  732.9094    10
#
# m=1001:
# Unit: milliseconds
#            expr       min        lq      mean    median        uq        max neval
#  lc_Nelder_Mead 1091.6772 1169.9430 1212.5945 1226.2528 1255.3913  1300.0997    10
#         lc_BFGS  528.2959  542.0339  568.9238  569.8263  586.5533   617.1882    10
#          lc_NLM  238.7890  252.3196  262.7388  262.4054  275.5777   281.4746    10
#  ll_Nelder_Mead 9414.1943 9582.6263 9750.1471 9741.9744 9920.1234 10080.0480    10
#         ll_BFGS 1630.2858 1656.0706 1700.2701 1699.5673 1739.3714  1792.3576    10
#          ll_NLM 2252.2240 2286.9975 2331.0192 2315.5427 2368.9760  2494.0073    10
boxplot(mb_times, las=2, xlab="", cex.axis=.6)
if (do_pdf) dev.off()
```

```{r, echo=FALSE, eval=FALSE}
if (m==201){
  save.image(file="One_Simulated_Beta_Curve_m_201.Rdata")
}
if (m==1001){
  save.image(file="One_Simulated_Beta_Curve_m_1001.Rdata")
}
```


**Conclusions:**

The 3 optimization methods produce essentially the same estimation results, with different computation times:
  
  - In local constant, NLM is the fastest method, followed by BFGS and them Nelder-Mead
  - In local linear and m=201, NLM is the fastest method, with times almost equal to BFGS, and them Nelder-Mead much slower.
  - In local linear and m=1001, BFGS is the fastest method, followed by NLM and them Nelder-Mead
  - For $m=201$, Local constant NLM is around 10 times faster than local linear BFGS.
  - For $m=1001$, Local constant NLM is around 6-7 times faster than local linear BFGS.
  - For $m=1001$ the computation times are around 5 times those of $m=201$ (time proportional to sample size $m$).
  
So we decide


### Bandwidth choice 

#### Local constant Beta: looCV, approximated looCV, and k-fold CV for one curve

```{r} 
vh<- seq(.02,.1, by=.02)
system.time(
loo_1sim <- looCV_loclikBeta_2(t, y,
                 vh=vh,
                 method="nlm", gr=grad_local_log_lik_2, 
                 myBeta=FALSE, mv=FALSE)
)
       # m=201:
       # usuari       sistema transcorregut 
       #   0.66          0.00          0.75
#
       # m=1001:
       # usuari       sistema transcorregut 
       #  10.60          0.09         11.19 

h_star <- h_loo <- loo_1sim$vh[which.max(loo_1sim$loglik)]

plot(loo_1sim$vh, loo_1sim$loglik)
abline(v=h_loo,col=2)
```

```{r} 
vh<- seq(.02,.1, by=.02)
system.time(
infl_1sim <- infl_looCV_loclikBeta_2nd_2(t, y,
                 vh=vh,
                 method="nlm", gr=grad_local_log_lik_2, 
                 myBeta=FALSE, mv=FALSE)
)
       # m=201
       # usuari       sistema transcorregut 
       #   2.36          0.19          2.70
#
       # m=1001
       # usuari       sistema transcorregut 
       # 170.31         22.12        199.03
         
h_star <- h_loo <- infl_1sim$vh[which.max(infl_1sim$loologlik)]

plot(infl_1sim$vh, infl_1sim$loologlik)
abline(v=h_loo,col=2)
```

```{r} 
vh<- seq(.02,.1, by=.02)
system.time(
kfCV_1sim <- k_fold_CV_loclikBeta_2(t, y,
                 vh=vh,
                 method="nlm", gr=grad_local_log_lik_2, 
                 myBeta=FALSE, mv=FALSE)
)
       # m=201:
       # usuari       sistema transcorregut 
       #   0.62          0.00          0.69
#
       # m=1001:
       # usuari       sistema transcorregut 
       #   8.30          0.10          8.73 

h_star_lc <- h_star <- h_kfCV <- kfCV_1sim$vh[which.max(kfCV_1sim$loglik)]

plot(kfCV_1sim$vh, kfCV_1sim$loglik)
abline(v=h_kfCV,col=2)
```

```{r}
loclikBeta_out_lc <- loclikBeta_out <- 
  loc_lik_Beta_nlm_2(t=t, y=y, h=h_star_lc, 
                     newt=newt, myBeta=myBeta, mv=mv)
if (mv){
  npar <- dim(loclikBeta_out$ab)[2] # 2 or 4
  par1 <- loclikBeta_out$ab[,1] 
#  par1 <- smooth.spline(newt,par1,df=15)$y
  par2 <- loclikBeta_out$ab[,1+npar/2]
#  par2 <- smooth.spline(newt,par2,df=15)$y
  mu  <- exp(par1)/(1+exp(par1))
  var <- exp(par2)
  aux_denom <- mu*(1-mu)/var - 1
  alphat <- mu*aux_denom   # alpha
  betat <- aux_denom - alphat # beta
  mt <- mu
  st <- sqrt(var)
}else{
  deltat <- loclikBeta_out$deltat 
#  deltat <-  smooth.spline(newt,deltat,df=15)$y
  etat <- loclikBeta_out$etat
#  etat <-  smooth.spline(newt,etat,df=15)$y
  alphat <- exp(deltat) 
  betat <- exp(etat)
  mt <- alphat/(alphat+betat)
  st <- sqrt(mt*(1-mt)/(alphat+betat+1))
}

q025t <- qbeta(.025,alphat,betat)
q500t <- qbeta(.5,alphat,betat)
q975t <- qbeta(.975,alphat,betat)

plot(t,y, ylim=c(0,1), pch=19, cex=.5,col="darkgreen",
     xlab=expression(t[j]),
     ylab=expression(Y(t[j])),
     main=paste("h_star=",h_star_lc))
lines(newt,mt,col=1,lwd=2)
lines(newt,q500t,col=2,lty=2,lwd=3)
lines(newt,q025t,col=4,lty=4,lwd=3)
lines(newt,q975t,col=4,lty=4,lwd=3)
```


#### Local linear Beta: looCV, approximated looCV, and k-fold CV for one curve

```{r} 
vh<- seq(.1,.2, by=.02)
system.time(
loo_1sim <- looCV_loclikBeta(t, y,
                 vh=vh,
                 method="BFGS", gr=grad_local_log_lik, 
                 myBeta=FALSE, mv=FALSE)
)
       # m=201:
       # usuari       sistema transcorregut 
       #   4.78          0.04          5.14 
#
       # m=1001:
       # usuari       sistema transcorregut 
       #  99.44          1.14        104.05 

h_star <- h_loo <- loo_1sim$vh[which.max(loo_1sim$loglik)]

plot(loo_1sim$vh, loo_1sim$loglik)
abline(v=h_loo,col=2)
```

```{r} 
vh<- seq(.1,.2, by=.02)
system.time(
infl_1sim <- infl_looCV_loclikBeta_2nd(t, y,
                 vh=vh,
                 method="BFGS", gr=grad_local_log_lik, 
                 myBeta=FALSE, mv=FALSE)
)
       # m=201:
       # usuari       sistema transcorregut 
       #   7.48          0.13          8.08
#
       # m=1001:
       # usuari       sistema transcorregut 
       # 305.09         28.85        341.17
         
h_star <- h_loo <- infl_1sim$vh[which.max(infl_1sim$loologlik)]

plot(infl_1sim$vh, infl_1sim$loologlik)
abline(v=h_loo,col=2)
```

```{r} 
vh<- seq(.1,.2, by=.02)
system.time(
kfCV_1sim <- k_fold_CV_loclikBeta(t, y,
                 vh=vh,
                 method="BFGS", gr=grad_local_log_lik, 
                 myBeta=FALSE, mv=FALSE)
)
       # m=201:
       # usuari       sistema transcorregut 
       #   3.91          0.03          4.16
#
       # m=1001:
       # usuari       sistema transcorregut 
       #  77.77          0.90         80.88
         
h_star_ll <- h_star <- h_kfCV <- kfCV_1sim$vh[which.max(kfCV_1sim$loglik)]

plot(kfCV_1sim$vh, kfCV_1sim$loglik)
abline(v=h_kfCV,col=2)
```

```{r}
loclikBeta_out_ll <- loclikBeta_out <- 
  loc_lik_Beta(t=t, y=y, h=h_star_ll, method = "BFGS",  
                     newt=newt, myBeta=myBeta, mv=mv)
if (mv){
  npar <- dim(loclikBeta_out$ab)[2] # 2 or 4
  par1 <- loclikBeta_out$ab[,1] 
#  par1 <- smooth.spline(newt,par1,df=15)$y
  par2 <- loclikBeta_out$ab[,1+npar/2]
#  par2 <- smooth.spline(newt,par2,df=15)$y
  mu  <- exp(par1)/(1+exp(par1))
  var <- exp(par2)
  aux_denom <- mu*(1-mu)/var - 1
  alphat <- mu*aux_denom   # alpha
  betat <- aux_denom - alphat # beta
  mt <- mu
  st <- sqrt(var)
}else{
  deltat <- loclikBeta_out$deltat 
#  deltat <-  smooth.spline(newt,deltat,df=15)$y
  etat <- loclikBeta_out$etat
#  etat <-  smooth.spline(newt,etat,df=15)$y
  alphat <- exp(deltat) 
  betat <- exp(etat)
  mt <- alphat/(alphat+betat)
  st <- sqrt(mt*(1-mt)/(alphat+betat+1))
}

q025t <- qbeta(.025,alphat,betat)
q500t <- qbeta(.5,alphat,betat)
q975t <- qbeta(.975,alphat,betat)

plot(t,y, ylim=c(0,1), pch=19, cex=.5,col="darkgreen",
     xlab=expression(t[j]),
     ylab=expression(Y(t[j])),
     main=paste("h_star=",h_star_ll))
lines(newt,mt,col=1,lwd=2)
lines(newt,q500t,col=2,lty=2,lwd=3)
lines(newt,q025t,col=4,lty=4,lwd=3)
lines(newt,q975t,col=4,lty=4,lwd=3)
```


#### Microbenchmarking the bandwidth choice methods

```{r, eval=FALSE, echo=FALSE}
library(microbenchmark)
band_choice_times <- microbenchmark(
  lc_loo= looCV_loclikBeta_2(t, y,
                 vh=vh,
                 method="nlm", gr=grad_local_log_lik_2, 
                 myBeta=FALSE, mv=FALSE),
  lc_infl= infl_looCV_loclikBeta_2nd_2(t, y,
                 vh=vh,
                 method="nlm", gr=grad_local_log_lik_2, 
                 myBeta=FALSE, mv=FALSE),
  lc_kfold= k_fold_CV_loclikBeta_2(t, y,
                 vh=vh,
                 method="nlm", gr=grad_local_log_lik_2, 
                 myBeta=FALSE, mv=FALSE),
  ll_loo= looCV_loclikBeta(t, y,
                 vh=vh,
                 method="BFGS", gr=grad_local_log_lik, 
                 myBeta=FALSE, mv=FALSE),
  ll_infl= infl_looCV_loclikBeta_2nd(t, y,
                 vh=vh,
                 method="BFGS", gr=grad_local_log_lik, 
                 myBeta=FALSE, mv=FALSE),
  ll_kfold= k_fold_CV_loclikBeta(t, y,
                 vh=vh,
                 method="BFGS", gr=grad_local_log_lik, 
                 myBeta=FALSE, mv=FALSE),
  times=10
)
```


```{r, fig.width=7,fig.height=5, eval=FALSE, echo=FALSE}
if (do_pdf) pdf(file="box_plot_band_choice_micro_bench_m_201.pdf", width=7, height=5)
summary(band_choice_times)

# m=201:
#Unit: milliseconds
#       expr        min         lq       mean     median         uq        max neval
# 1   lc_loo   525.2357   617.7481   677.8130   665.0854   756.8433   816.5764    10
# 2  lc_infl  1752.8510  1933.6777  2227.0891  2241.4037  2509.1642  2690.1614    10
# 3 lc_kfold   445.4487   468.7593   507.7047   500.1790   544.4316   600.9868    10
# 4   ll_loo  8341.0759  8399.1707  9798.2985  9627.3201 10992.4309 11633.0110    10
# 5  ll_infl 10814.6960 11049.5124 12788.4395 11610.1223 15000.6917 15525.6238    10
# 6 ll_kfold  8295.9996  8451.5038  9517.7376  9643.1922 10283.9070 11475.2595    10

# m=1001:
# Unit: seconds
#      expr        min         lq       mean     median         uq       max neval
#    lc_loo  11.556392  11.760065  12.215925  12.111247  12.630892  13.23503    10
#   lc_infl 188.869230 190.804120 194.360366 192.836068 197.043645 203.33102    10
#  lc_kfold   9.019851   9.391309   9.623293   9.544927   9.796315  10.45609    10
#    ll_loo 135.517630 140.330806 151.830124 146.554265 162.021360 185.84823    10
#   ll_infl 343.550949 343.669805 349.527011 345.984666 356.156404 360.80805    10
#  ll_kfold 111.513907 113.497857 117.563927 116.033302 117.839438 137.13751    10
boxplot(band_choice_times, las=2, xlab="", cex.axis=.6)
if (do_pdf) dev.off()
```


```{r, echo=FALSE, eval=FALSE}
save.image(file="band_choice_One_Simulated_Beta_Curve_m_201.Rdata")
```

**Conclusions:**

We have compared 3 bandwidth choice methods for local constant and local linear likelihood estimation:
  
  - bandwidth choice methods in local constant is between 5 and 20 times faster than in local linear.
  - 5-fold CV is slightly faster than loo (more clear when m=201 than when m=1001).
  - approximated loo based on the influence function is considerable slower than loo and 5-fold CV: about 4 times slower in local constant estimation, and 1.2 times in local linear estimation.

In conclusion, we find that the approximate LOO method based on the influence function does not reduce computation time compared to crude cross-validation (CV) methods. 




## 2x2 plots in 1 page 

```{r, fig.width=7.2, fig.height=7}
if (do_pdf) pdf("2x2_One_Beta_Simul.pdf", 
                width = 7.2, height = 7)
op<-par(mfrow=c(2,2))

# plot 1
plot(t,alpha, type="l", lwd=2, lty=1,
     ylim=range(c(alpha, beta)),
     ylab=expression(paste(alpha(t),",  ",beta(t))),
     main="True Beta functional parameters")
lines(t, beta, lwd=2, lty=2)
legend("topright",
       c(expression(alpha(t)),
         expression(beta(t))), 
       col=1, lty=c(1,2), lwd=2,
       bty="n", cex=1, seg.len = 3.5)
# plot 2
plot(t,Y, ylim=c(0,1), 
     xlab=expression(t[j]),
     ylab=expression(Y(t[j])),
     pch=19, cex=.5, col="darkgreen",
     main="True distributions and random data")
lines(t,mu,lwd=2)
lines(t,q500,lwd=3,col=2,lty=2)
lines(t,q025,lwd=3,col=4,lty=4)
lines(t,q975,lwd=3,col=4,lty=4)

legend("topright",
       c("Mean(t)", "Median(t)", 
         expression(Q[.025](t)),
         expression(Q[.975](t))),
       col=c(1,2,4), lty=c(1,2,4), lwd=c(2,3,3),
       bty="n", cex=1, seg.len = 3.5)

# plot 3
loclikBeta_out <- loclikBeta_out_lc
deltat <- loclikBeta_out$deltat 
etat <- loclikBeta_out$etat
alphat <- exp(deltat) 
betat <- exp(etat)
mt <- alphat/(alphat+betat)
st <- sqrt(mt*(1-mt)/(alphat+betat+1))
q025t <- qbeta(.025,alphat,betat)
q500t <- qbeta(.5,alphat,betat)
q975t <- qbeta(.975,alphat,betat)

plot(t,y, ylim=c(0,1), pch=19, cex=.5,col="darkgreen",
     xlab=expression(t[j]),
     ylab=expression(Y(t[j])),
     main=paste("Local constant estimation, h*=",h_star_lc))
lines(newt,mt,col=1,lwd=2)
lines(newt,q500t,col=2,lty=2,lwd=3)
lines(newt,q025t,col=4,lty=4,lwd=3)
lines(newt,q975t,col=4,lty=4,lwd=3)

# plot 4
loclikBeta_out <- loclikBeta_out_ll
deltat <- loclikBeta_out$deltat 
etat <- loclikBeta_out$etat
alphat <- exp(deltat) 
betat <- exp(etat)
mt <- alphat/(alphat+betat)
st <- sqrt(mt*(1-mt)/(alphat+betat+1))
q025t <- qbeta(.025,alphat,betat)
q500t <- qbeta(.5,alphat,betat)
q975t <- qbeta(.975,alphat,betat)

plot(t,y, ylim=c(0,1), pch=19, cex=.5,col="darkgreen",
     xlab=expression(t[j]),
     ylab=expression(Y(t[j])),
     main=paste("Local linear estimation, h*=",h_star_ll))
lines(newt,mt,col=1,lwd=2)
lines(newt,q500t,col=2,lty=2,lwd=3)
lines(newt,q025t,col=4,lty=4,lwd=3)
lines(newt,q975t,col=4,lty=4,lwd=3)

par(op)
if (do_pdf) dev.off()
```




## 3x2 plots in 1 page. Version A

```{r, fig.width=7.2, fig.height=10.5}
if (do_pdf) pdf("3x2_One_Beta_Simul_A.pdf", 
                width = 7.2, height = 7)
op<-par(mfrow=c(3,2))

# plot 1
plot(t,alpha, type="l", lwd=2, lty=1,
     ylim=range(c(alpha, beta)),
     ylab=expression(paste(alpha(t),",  ",beta(t))),
     main="True Beta functional parameters")
lines(t, beta, lwd=2, lty=2)
legend("topright",
       c(expression(alpha(t)),
         expression(beta(t))), 
       col=1, lty=c(1,2), lwd=2,
       bty="n", cex=1, seg.len = 3.5)
# plot 2
plot(t,Y, ylim=c(0,1), 
     xlab=expression(t[j]),
     ylab=expression(Y(t[j])),
     pch=19, cex=.5, col="darkgreen",
     main="True distributions and random data")
lines(t,mu,lwd=2)
lines(t,q500,lwd=3,col=2,lty=2)
lines(t,q025,lwd=3,col=4,lty=4)
lines(t,q975,lwd=3,col=4,lty=4)

legend("topright",
       c("Mean(t)", "Median(t)", 
         expression(Q[.025](t)),
         expression(Q[.975](t))),
       col=c(1,2,4), lty=c(1,2,4), lwd=c(2,3,3),
       bty="n", cex=1, seg.len = 3.5)


# Plot 3 

plot(t,alpha,type="l",lwd=2, ylab=expression(alpha(t)))
lines(newt, exp(loclikBeta_out_lc_1$deltat),lwd=2, col=5, lty=2)
lines(newt, exp(loclikBeta_out_lc_2$deltat),lwd=2, col=3, lty=2)
lines(newt, exp(loclikBeta_out_lc_3$deltat),lwd=2, col=2, lty=2)
lines(newt, exp(loclikBeta_out_ll_1$deltat),lwd=2, col=7, lty=4)
lines(newt, exp(loclikBeta_out_ll_2$deltat),lwd=2, col=6, lty=4)
lines(newt, exp(loclikBeta_out_ll_3$deltat),lwd=2, col=4, lty=4)
legend("topright",
       c(expression(paste("True ", alpha,"(t)")),
         "3 local constant estims", 
         "3 local linear estims"),
       col=c(1,2,4),lwd=2,
       lty=c(1,2,4),
       bty="n", cex=.75, seg.len = 3.5)


# plot 4

plot(t,beta,type="l",lwd=2, ylab=expression(beta(t)), ylim=range(alpha))
lines(newt, exp(loclikBeta_out_lc_1$eta),lwd=2, col=5, lty=2)
lines(newt, exp(loclikBeta_out_lc_2$eta),lwd=2, col=3, lty=2)
lines(newt, exp(loclikBeta_out_lc_3$eta),lwd=2, col=2, lty=2)
lines(newt, exp(loclikBeta_out_ll_1$eta),lwd=2, col=7, lty=4)
lines(newt, exp(loclikBeta_out_ll_2$eta),lwd=2, col=6, lty=4)
lines(newt, exp(loclikBeta_out_ll_3$eta),lwd=2, col=4, lty=4)
legend("topright",
       c(expression(paste("True ", beta,"(t)")),
         "3 local constant estims", 
         "3 local linear estims"),
       col=c(1,2,4),lwd=2,
       lty=c(1,2,4),
       bty="n", cex=.75, seg.len = 3.5)

# plot 5
loclikBeta_out <- loclikBeta_out_lc
deltat <- loclikBeta_out$deltat 
etat <- loclikBeta_out$etat
alphat <- exp(deltat) 
betat <- exp(etat)
mt <- alphat/(alphat+betat)
st <- sqrt(mt*(1-mt)/(alphat+betat+1))
q025t <- qbeta(.025,alphat,betat)
q500t <- qbeta(.5,alphat,betat)
q975t <- qbeta(.975,alphat,betat)

plot(t,y, ylim=c(0,1), pch=19, cex=.5,col="darkgreen",
     xlab=expression(t[j]),
     ylab=expression(Y(t[j])),
     main=paste("Local constant estimation, h*=",h_star_lc))
lines(newt,mt,col=1,lwd=2)
lines(newt,q500t,col=2,lty=2,lwd=3)
lines(newt,q025t,col=4,lty=4,lwd=3)
lines(newt,q975t,col=4,lty=4,lwd=3)

# plot 6
loclikBeta_out <- loclikBeta_out_ll
deltat <- loclikBeta_out$deltat 
etat <- loclikBeta_out$etat
alphat <- exp(deltat) 
betat <- exp(etat)
mt <- alphat/(alphat+betat)
st <- sqrt(mt*(1-mt)/(alphat+betat+1))
q025t <- qbeta(.025,alphat,betat)
q500t <- qbeta(.5,alphat,betat)
q975t <- qbeta(.975,alphat,betat)

plot(t,y, ylim=c(0,1), pch=19, cex=.5,col="darkgreen",
     xlab=expression(t[j]),
     ylab=expression(Y(t[j])),
     main=paste("Local linear estimation, h*=",h_star_ll))
lines(newt,mt,col=1,lwd=2)
lines(newt,q500t,col=2,lty=2,lwd=3)
lines(newt,q025t,col=4,lty=4,lwd=3)
lines(newt,q975t,col=4,lty=4,lwd=3)

par(op)
if (do_pdf) dev.off()
```


## 3x2 plots in 1 page. Version B

```{r, fig.width=6, fig.height=8.75}
if (do_pdf) pdf("3x2_One_Beta_Simul_B.pdf", 
                width = 6, height = 8.75)
op<-par(mfrow=c(3,2))

# plot 1
plot(t,alpha, type="l", lwd=2, lty=1,
     ylim=range(c(alpha, beta)),
     ylab=expression(paste(alpha(t),",  ",beta(t))),
     main="True Beta functional parameters")
lines(t, beta, lwd=2, lty=2)
legend("topright",
       c(expression(alpha(t)),
         expression(beta(t))), 
       col=1, lty=c(1,2), lwd=2,
       bty="n", cex=1, seg.len = 3.5)
# plot 2
plot(t,Y, ylim=c(0,1), 
     xlab=expression(t[j]),
     ylab=expression(Y(t[j])),
     pch=19, cex=.5, col="darkgreen",
     main="True distributions and random data")
lines(t,mu,lwd=2)
lines(t,q500,lwd=3,col=2,lty=2)
lines(t,q025,lwd=3,col=4,lty=4)
lines(t,q975,lwd=3,col=4,lty=4)

legend("topright",
       c("Mean(t)", "Median(t)", 
         expression(Q[.025](t)),
         expression(Q[.975](t))),
       col=c(1,2,4), lty=c(1,2,4), lwd=c(2,3,3),
       bty="n", cex=1, seg.len = 3.5)


# Plot 3 

plot(t,alpha,type="l",lwd=2, 
     ylab=expression(alpha(t)),
          main=expression(paste("Estimation of ", alpha(t))))
lines(newt, exp(loclikBeta_out_lc_1$deltat),lwd=2, col=5, lty=2)
lines(newt, exp(loclikBeta_out_lc_2$deltat),lwd=2, col=3, lty=2)
lines(newt, exp(loclikBeta_out_lc_3$deltat),lwd=2, col=2, lty=2)
lines(newt, exp(loclikBeta_out_ll_1$deltat),lwd=2, col=7, lty=4)
lines(newt, exp(loclikBeta_out_ll_2$deltat),lwd=2, col=6, lty=4)
lines(newt, exp(loclikBeta_out_ll_3$deltat),lwd=2, col=4, lty=4)
legend("topright",
       c(expression(paste("True ", alpha,"(t)")),
         "3 local constant estims", 
         "3 local linear estims"),
       col=c(1,2,4),lwd=2,
       lty=c(1,2,4),
       bty="n", cex=.75, seg.len = 3.5)


# plot 4
loclikBeta_out <- loclikBeta_out_lc
deltat <- loclikBeta_out$deltat 
etat <- loclikBeta_out$etat
alphat <- exp(deltat) 
betat <- exp(etat)
mt <- alphat/(alphat+betat)
st <- sqrt(mt*(1-mt)/(alphat+betat+1))
q025t <- qbeta(.025,alphat,betat)
q500t <- qbeta(.5,alphat,betat)
q975t <- qbeta(.975,alphat,betat)

plot(t,y, ylim=c(0,1), pch=19, cex=.5,col="darkgreen",
     xlab=expression(t[j]),
     ylab=expression(Y(t[j])),
     main=paste("Local constant estimation, h*=",h_star_lc))
lines(newt,mt,col=1,lwd=2)
lines(newt,q500t,col=2,lty=2,lwd=3)
lines(newt,q025t,col=4,lty=4,lwd=3)
lines(newt,q975t,col=4,lty=4,lwd=3)

# plot 5

plot(t,beta,type="l",lwd=2, 
     ylab=expression(beta(t)),
     main=expression(paste("Estimation of ", beta(t))),
     ylim=range(alpha))
lines(newt, exp(loclikBeta_out_lc_1$eta),lwd=2, col=5, lty=2)
lines(newt, exp(loclikBeta_out_lc_2$eta),lwd=2, col=3, lty=2)
lines(newt, exp(loclikBeta_out_lc_3$eta),lwd=2, col=2, lty=2)
lines(newt, exp(loclikBeta_out_ll_1$eta),lwd=2, col=7, lty=4)
lines(newt, exp(loclikBeta_out_ll_2$eta),lwd=2, col=6, lty=4)
lines(newt, exp(loclikBeta_out_ll_3$eta),lwd=2, col=4, lty=4)
legend("topright",
       c(expression(paste("True ", beta,"(t)")),
         "3 local constant estims", 
         "3 local linear estims"),
       col=c(1,2,4),lwd=2,
       lty=c(1,2,4),
       bty="n", cex=.75, seg.len = 3.5)

# plot 6
loclikBeta_out <- loclikBeta_out_ll
deltat <- loclikBeta_out$deltat 
etat <- loclikBeta_out$etat
alphat <- exp(deltat) 
betat <- exp(etat)
mt <- alphat/(alphat+betat)
st <- sqrt(mt*(1-mt)/(alphat+betat+1))
q025t <- qbeta(.025,alphat,betat)
q500t <- qbeta(.5,alphat,betat)
q975t <- qbeta(.975,alphat,betat)

plot(t,y, ylim=c(0,1), pch=19, cex=.5,col="darkgreen",
     xlab=expression(t[j]),
     ylab=expression(Y(t[j])),
     main=paste("Local linear estimation, h*=",h_star_ll))
lines(newt,mt,col=1,lwd=2)
lines(newt,q500t,col=2,lty=2,lwd=3)
lines(newt,q025t,col=4,lty=4,lwd=3)
lines(newt,q975t,col=4,lty=4,lwd=3)

par(op)
if (do_pdf) dev.off()
```